export interface ItineraryEvent {
  title: string;
  description?: string;
  location?: string;
  startTime: Date;
  endTime: Date;
  type: 'accommodation' | 'restaurant' | 'tour' | 'event' | 'transit';
  venue?: {
    name: string;
    address: string;
    website?: string;
    safetyScore?: number;
  };
}

export interface DailyItinerary {
  date: Date;
  events: ItineraryEvent[];
}

export interface TripItinerary {
  title: string;
  description?: string;
  destination: string;
  days: DailyItinerary[];
}

// Generate a unique ID for calendar events
function generateEventId(): string {
  return Math.random().toString(36).substr(2, 9) + '@veganbnb.com';
}

// Format date for .ics format (YYYYMMDDTHHMMSSZ)
function formatIcsDate(date: Date): string {
  return date.toISOString().replace(/[-:]/g, '').replace(/\.\d{3}/, '');
}

// Escape special characters for .ics format
function escapeIcsText(text: string): string {
  return text
    .replace(/\\/g, '\\\\')
    .replace(/;/g, '\\;')
    .replace(/,/g, '\\,')
    .replace(/\n/g, '\\n')
    .replace(/\r/g, '');
}

// Generate .ics content for a trip itinerary
export function generateIcsContent(itinerary: TripItinerary): string {
  const now = new Date();
  const timestamp = formatIcsDate(now);
  
  const icsContent = [
    'BEGIN:VCALENDAR',
    'VERSION:2.0',
    'PRODID:-//VeganBnB//Travel Itinerary//EN',
    'CALSCALE:GREGORIAN',
    'METHOD:PUBLISH',
    `X-WR-CALNAME:${escapeIcsText(itinerary.title)}`,
    `X-WR-CALDESC:${escapeIcsText(itinerary.description || `Vegan travel itinerary for ${itinerary.destination}`)}`
  ];

  // Process each day and event
  for (const day of itinerary.days) {
    for (const event of day.events) {
      const eventId = generateEventId();
      const startTime = formatIcsDate(event.startTime);
      const endTime = formatIcsDate(event.endTime);
      
      // Build event description
      let description = event.description || '';
      if (event.venue) {
        if (description) description += '\\n\\n';
        description += `ðŸ“ ${escapeIcsText(event.venue.address)}`;
        if (event.venue.website) {
          description += `\\nðŸŒ ${escapeIcsText(event.venue.website)}`;
        }
        if (event.venue.safetyScore) {
          description += `\\nâœ… Safety Score: ${event.venue.safetyScore}/100`;
        }
        description += '\\n\\nðŸŒ± Generated by VeganBnB';
      }

      icsContent.push(
        'BEGIN:VEVENT',
        `UID:${eventId}`,
        `DTSTAMP:${timestamp}`,
        `DTSTART:${startTime}`,
        `DTEND:${endTime}`,
        `SUMMARY:${escapeIcsText(event.title)}`,
        description ? `DESCRIPTION:${description}` : '',
        event.location ? `LOCATION:${escapeIcsText(event.location)}` : '',
        `CATEGORIES:${event.type.toUpperCase()}`,
        'STATUS:CONFIRMED',
        'TRANSP:OPAQUE',
        'END:VEVENT'
      );
    }
  }

  icsContent.push('END:VCALENDAR');
  
  return icsContent.filter(line => line !== '').join('\r\n');
}

// Download .ics file
export function downloadIcsFile(itinerary: TripItinerary): void {
  const icsContent = generateIcsContent(itinerary);
  const blob = new Blob([icsContent], { type: 'text/calendar;charset=utf-8' });
  
  // Create download link
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);
  link.href = url;
  
  // Generate filename from itinerary title and dates
  const startDate = itinerary.days[0]?.date;
  const dateStr = startDate ? startDate.toISOString().split('T')[0] : 'trip';
  const filename = `${itinerary.destination.toLowerCase().replace(/\s+/g, '-')}-vegan-trip-${dateStr}.ics`;
  
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  
  // Cleanup
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

// Calculate travel time between two addresses (simplified)
export function estimateTravelTime(fromAddress: string, toAddress: string, mode: 'walking' | 'transit' = 'walking'): number {
  // Simplified estimation - in real app would use Google Maps API
  // Returns minutes
  const baseTime = mode === 'walking' ? 15 : 10;
  return baseTime + Math.floor(Math.random() * 10); // 15-25 min walking, 10-20 min transit
}

// Generate transit events between venues
export function createTransitEvent(
  from: string,
  to: string,
  departureTime: Date,
  mode: 'walking' | 'transit' = 'walking'
): ItineraryEvent {
  const travelMinutes = estimateTravelTime(from, to, mode);
  const arrivalTime = new Date(departureTime.getTime() + travelMinutes * 60000);
  
  const modeEmoji = mode === 'walking' ? 'ðŸš¶' : 'ðŸš‡';
  const modeText = mode === 'walking' ? 'Walk' : 'Transit';
  
  return {
    title: `${modeEmoji} ${modeText} to ${to.split(',')[0]}`,
    description: `Travel from ${from} to ${to}`,
    startTime: departureTime,
    endTime: arrivalTime,
    type: 'transit',
    location: `${from} â†’ ${to}`
  };
}

// Smart itinerary builder that adds transit between venues
export function buildSmartItinerary(
  venues: Array<{
    name: string;
    address: string;
    startTime: Date;
    endTime: Date;
    type: 'restaurant' | 'tour' | 'event';
    description?: string;
    website?: string;
    safetyScore?: number;
  }>,
  accommodation?: {
    name: string;
    address: string;
    checkIn: Date;
    checkOut: Date;
    website?: string;
    safetyScore?: number;
  }
): ItineraryEvent[] {
  const events: ItineraryEvent[] = [];
  
  // Add accommodation as full-day event
  if (accommodation) {
    events.push({
      title: `ðŸ¨ ${accommodation.name}`,
      description: 'Accommodation',
      location: accommodation.address,
      startTime: accommodation.checkIn,
      endTime: accommodation.checkOut,
      type: 'accommodation',
      venue: {
        name: accommodation.name,
        address: accommodation.address,
        website: accommodation.website,
        safetyScore: accommodation.safetyScore
      }
    });
  }
  
  // Sort venues by start time
  const sortedVenues = venues.sort((a, b) => a.startTime.getTime() - b.startTime.getTime());
  
  // Add venue events with transit
  for (let i = 0; i < sortedVenues.length; i++) {
    const venue = sortedVenues[i];
    const prevVenue = i > 0 ? sortedVenues[i - 1] : null;
    
    // Add transit event if not the first venue
    if (prevVenue) {
      const transitStart = prevVenue.endTime;
      const transitEnd = new Date(venue.startTime.getTime() - 5 * 60000); // 5 min buffer
      
      if (transitEnd > transitStart) {
        const transitEvent = createTransitEvent(
          prevVenue.address,
          venue.address,
          transitStart,
          'walking'
        );
        events.push(transitEvent);
      }
    }
    
    // Add venue event
    const typeEmojis = {
      restaurant: 'ðŸ½ï¸',
      tour: 'ðŸŽ¯',
      event: 'ðŸŽ‰'
    };
    
    events.push({
      title: `${typeEmojis[venue.type]} ${venue.name}`,
      description: venue.description,
      location: venue.address,
      startTime: venue.startTime,
      endTime: venue.endTime,
      type: venue.type,
      venue: {
        name: venue.name,
        address: venue.address,
        website: venue.website,
        safetyScore: venue.safetyScore
      }
    });
  }
  
  return events.sort((a, b) => a.startTime.getTime() - b.startTime.getTime());
}